{"ast":null,"code":"import { focusSafely as $6a99195332edec8b$export$80f3e147d781571c } from \"./focusSafely.mjs\";\nimport { isElementVisible as $645f2e67b85a24c9$export$e989c0fffaa6b27a } from \"./isElementVisible.mjs\";\nimport { useLayoutEffect as $cgawC$useLayoutEffect, getOwnerDocument as $cgawC$getOwnerDocument } from \"@react-aria/utils\";\nimport $cgawC$react, { useRef as $cgawC$useRef, useContext as $cgawC$useContext, useMemo as $cgawC$useMemo, useEffect as $cgawC$useEffect } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/(0, $cgawC$react).createContext(null);\nlet $9bf71ea28793e738$var$activeScope = null;\nfunction $9bf71ea28793e738$export$20e40289641fbbb6(props) {\n  let {\n    children: children,\n    contain: contain,\n    restoreFocus: restoreFocus,\n    autoFocus: autoFocus\n  } = props;\n  let startRef = (0, $cgawC$useRef)(null);\n  let endRef = (0, $cgawC$useRef)(null);\n  let scopeRef = (0, $cgawC$useRef)([]);\n  let {\n    parentNode: parentNode\n  } = (0, $cgawC$useContext)($9bf71ea28793e738$var$FocusContext) || {};\n  // Create a tree node here so we can add children to it even before it is added to the tree.\n  let node = (0, $cgawC$useMemo)(() => new $9bf71ea28793e738$var$TreeNode({\n    scopeRef: scopeRef\n  }), [scopeRef]);\n  (0, $cgawC$useLayoutEffect)(() => {\n    // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n    // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n    // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n    // that is being added should get the activeScope as its parent.\n    let parent = parentNode || $9bf71ea28793e738$export$d06fae2ee68b101e.root;\n    if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, parent.scopeRef)) {\n      let activeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n      if (activeNode) parent = activeNode;\n    }\n    // Add the node to the parent, and to the tree.\n    parent.addChild(node);\n    $9bf71ea28793e738$export$d06fae2ee68b101e.addNode(node);\n  }, [node, parentNode]);\n  (0, $cgawC$useLayoutEffect)(() => {\n    let node = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n    if (node) node.contain = !!contain;\n  }, [contain]);\n  (0, $cgawC$useLayoutEffect)(() => {\n    var _startRef_current;\n    // Find all rendered nodes between the sentinels and add them to the scope.\n    let node = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;\n    let nodes = [];\n    while (node && node !== endRef.current) {\n      nodes.push(node);\n      node = node.nextSibling;\n    }\n    scopeRef.current = nodes;\n  }, [children]);\n  $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);\n  $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);\n  $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);\n  $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);\n  // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n  // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n  (0, $cgawC$useEffect)(() => {\n    const activeElement = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;\n    let scope = null;\n    if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {\n      // We need to traverse the focusScope tree and find the bottom most scope that\n      // contains the active element and set that as the activeScope.\n      for (let node of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse()) if (node.scopeRef && $9bf71ea28793e738$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;\n      if (scope === $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $9bf71ea28793e738$var$activeScope = scope.scopeRef;\n    }\n  }, [scopeRef]);\n  // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n  // in useRestoreFocus cleanup runs.\n  (0, $cgawC$useLayoutEffect)(() => {\n    return () => {\n      var _focusScopeTree_getTreeNode_parent, _focusScopeTree_getTreeNode;\n      var _focusScopeTree_getTreeNode_parent_scopeRef;\n      // Scope may have been re-parented.\n      let parentScope = (_focusScopeTree_getTreeNode_parent_scopeRef = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : (_focusScopeTree_getTreeNode_parent = _focusScopeTree_getTreeNode.parent) === null || _focusScopeTree_getTreeNode_parent === void 0 ? void 0 : _focusScopeTree_getTreeNode_parent.scopeRef) !== null && _focusScopeTree_getTreeNode_parent_scopeRef !== void 0 ? _focusScopeTree_getTreeNode_parent_scopeRef : null;\n      if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope))) $9bf71ea28793e738$var$activeScope = parentScope;\n      $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);\n    };\n  }, [scopeRef]);\n  let focusManager = (0, $cgawC$useMemo)(() => $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef), []);\n  let value = (0, $cgawC$useMemo)(() => ({\n    focusManager: focusManager,\n    parentNode: node\n  }), [node, focusManager]);\n  return /*#__PURE__*/(0, $cgawC$react).createElement($9bf71ea28793e738$var$FocusContext.Provider, {\n    value: value\n  }, /*#__PURE__*/(0, $cgawC$react).createElement(\"span\", {\n    \"data-focus-scope-start\": true,\n    hidden: true,\n    ref: startRef\n  }), children, /*#__PURE__*/(0, $cgawC$react).createElement(\"span\", {\n    \"data-focus-scope-end\": true,\n    hidden: true,\n    ref: endRef\n  }));\n}\nfunction $9bf71ea28793e738$export$10c5169755ce7bd7() {\n  var _useContext;\n  return (_useContext = (0, $cgawC$useContext)($9bf71ea28793e738$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;\n}\nfunction $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {\n  return {\n    focusNext(opts = {}) {\n      let scope = scopeRef.current;\n      let {\n        from: from,\n        tabbable: tabbable,\n        wrap: wrap,\n        accept: accept\n      } = opts;\n      let node = from || (0, $cgawC$getOwnerDocument)(scope[0]).activeElement;\n      let sentinel = scope[0].previousElementSibling;\n      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: tabbable,\n        accept: accept\n      }, scope);\n      walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n      let nextNode = walker.nextNode();\n      if (!nextNode && wrap) {\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode();\n      }\n      if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n      return nextNode;\n    },\n    focusPrevious(opts = {}) {\n      let scope = scopeRef.current;\n      let {\n        from: from,\n        tabbable: tabbable,\n        wrap: wrap,\n        accept: accept\n      } = opts;\n      let node = from || (0, $cgawC$getOwnerDocument)(scope[0]).activeElement;\n      let sentinel = scope[scope.length - 1].nextElementSibling;\n      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: tabbable,\n        accept: accept\n      }, scope);\n      walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n      let previousNode = walker.previousNode();\n      if (!previousNode && wrap) {\n        walker.currentNode = sentinel;\n        previousNode = walker.previousNode();\n      }\n      if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n      return previousNode;\n    },\n    focusFirst(opts = {}) {\n      let scope = scopeRef.current;\n      let {\n        tabbable: tabbable,\n        accept: accept\n      } = opts;\n      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: tabbable,\n        accept: accept\n      }, scope);\n      walker.currentNode = scope[0].previousElementSibling;\n      let nextNode = walker.nextNode();\n      if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n      return nextNode;\n    },\n    focusLast(opts = {}) {\n      let scope = scopeRef.current;\n      let {\n        tabbable: tabbable,\n        accept: accept\n      } = opts;\n      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: tabbable,\n        accept: accept\n      }, scope);\n      walker.currentNode = scope[scope.length - 1].nextElementSibling;\n      let previousNode = walker.previousNode();\n      if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n      return previousNode;\n    }\n  };\n}\nconst $9bf71ea28793e738$var$focusableElements = [\"input:not([disabled]):not([type=hidden])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"button:not([disabled])\", \"a[href]\", \"area[href]\", \"summary\", \"iframe\", \"object\", \"embed\", \"audio[controls]\", \"video[controls]\", \"[contenteditable]\"];\nconst $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(\":not([hidden]),\") + \",[tabindex]:not([disabled]):not([hidden])\";\n$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\nfunction $9bf71ea28793e738$export$4c063cf1350e6fed(element) {\n  return element.matches($9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR);\n}\nfunction $9bf71ea28793e738$var$getScopeRoot(scope) {\n  return scope[0].parentElement;\n}\nfunction $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {\n  let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.contain) return false;\n    scope = scope.parent;\n  }\n  return true;\n}\nfunction $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {\n  let focusedNode = (0, $cgawC$useRef)();\n  let raf = (0, $cgawC$useRef)();\n  (0, $cgawC$useLayoutEffect)(() => {\n    let scope = scopeRef.current;\n    if (!contain) {\n      // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = undefined;\n      }\n      return;\n    }\n    const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);\n    // Handle the Tab key to contain focus within the scope\n    let onKeyDown = e => {\n      if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef) || e.isComposing) return;\n      let focusedElement = ownerDocument.activeElement;\n      let scope = scopeRef.current;\n      if (!scope || !$9bf71ea28793e738$var$isElementInScope(focusedElement, scope)) return;\n      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: true\n      }, scope);\n      if (!focusedElement) return;\n      walker.currentNode = focusedElement;\n      let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n      if (!nextElement) {\n        walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;\n        nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n      }\n      e.preventDefault();\n      if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n    };\n    let onFocus = e => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e.target, scopeRef.current)) {\n        $9bf71ea28793e738$var$activeScope = scopeRef;\n        focusedNode.current = e.target;\n      } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e.target, scopeRef)) {\n        // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n        // restore focus to the previously focused node or the first tabbable element in the active scope.\n        if (focusedNode.current) focusedNode.current.focus();else if ($9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n      } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;\n    };\n    let onBlur = e => {\n      // Firefox doesn't shift focus back to the Dialog properly without this\n      if (raf.current) cancelAnimationFrame(raf.current);\n      raf.current = requestAnimationFrame(() => {\n        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n        if (ownerDocument.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n          $9bf71ea28793e738$var$activeScope = scopeRef;\n          if (ownerDocument.body.contains(e.target)) {\n            var _focusedNode_current;\n            focusedNode.current = e.target;\n            (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();\n          } else if ($9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n        }\n      });\n    };\n    ownerDocument.addEventListener(\"keydown\", onKeyDown, false);\n    ownerDocument.addEventListener(\"focusin\", onFocus, false);\n    scope === null || scope === void 0 ? void 0 : scope.forEach(element => element.addEventListener(\"focusin\", onFocus, false));\n    scope === null || scope === void 0 ? void 0 : scope.forEach(element => element.addEventListener(\"focusout\", onBlur, false));\n    return () => {\n      ownerDocument.removeEventListener(\"keydown\", onKeyDown, false);\n      ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n      scope === null || scope === void 0 ? void 0 : scope.forEach(element => element.removeEventListener(\"focusin\", onFocus, false));\n      scope === null || scope === void 0 ? void 0 : scope.forEach(element => element.removeEventListener(\"focusout\", onBlur, false));\n    };\n  }, [scopeRef, contain]);\n  // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n  // eslint-disable-next-line arrow-body-style\n  (0, $cgawC$useLayoutEffect)(() => {\n    return () => {\n      if (raf.current) cancelAnimationFrame(raf.current);\n    };\n  }, [raf]);\n}\nfunction $9bf71ea28793e738$var$isElementInAnyScope(element) {\n  return $9bf71ea28793e738$var$isElementInChildScope(element);\n}\nfunction $9bf71ea28793e738$var$isElementInScope(element, scope) {\n  if (!element) return false;\n  if (!scope) return false;\n  return scope.some(node => node.contains(element));\n}\nfunction $9bf71ea28793e738$var$isElementInChildScope(element, scope = null) {\n  // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n  if (element instanceof Element && element.closest(\"[data-react-aria-top-layer]\")) return true;\n  // node.contains in isElementInScope covers child scopes that are also DOM children,\n  // but does not cover child scopes in portals.\n  for (let {\n    scopeRef: s\n  } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))) {\n    if (s && $9bf71ea28793e738$var$isElementInScope(element, s.current)) return true;\n  }\n  return false;\n}\nfunction $9bf71ea28793e738$export$1258395f99bf9cbf(element) {\n  return $9bf71ea28793e738$var$isElementInChildScope(element, $9bf71ea28793e738$var$activeScope);\n}\nfunction $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {\n  var _focusScopeTree_getTreeNode;\n  let parent = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;\n  while (parent) {\n    if (parent.scopeRef === ancestor) return true;\n    parent = parent.parent;\n  }\n  return false;\n}\nfunction $9bf71ea28793e738$var$focusElement(element, scroll = false) {\n  if (element != null && !scroll) try {\n    (0, $6a99195332edec8b$export$80f3e147d781571c)(element);\n  } catch (err) {\n    // ignore\n  } else if (element != null) try {\n    element.focus();\n  } catch (err) {\n    // ignore\n  }\n}\nfunction $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {\n  let sentinel = scope[0].previousElementSibling;\n  let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n  let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n    tabbable: tabbable\n  }, scope);\n  walker.currentNode = sentinel;\n  let nextNode = walker.nextNode();\n  // If the scope does not contain a tabbable element, use the first focusable element.\n  if (tabbable && !nextNode) {\n    scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n    walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n      tabbable: false\n    }, scope);\n    walker.currentNode = sentinel;\n    nextNode = walker.nextNode();\n  }\n  $9bf71ea28793e738$var$focusElement(nextNode);\n}\nfunction $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {\n  const autoFocusRef = (0, $cgawC$react).useRef(autoFocus);\n  (0, $cgawC$useEffect)(() => {\n    if (autoFocusRef.current) {\n      $9bf71ea28793e738$var$activeScope = scopeRef;\n      const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n      if (!$9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, $9bf71ea28793e738$var$activeScope.current) && scopeRef.current) $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);\n    }\n    autoFocusRef.current = false;\n  }, [scopeRef]);\n}\nfunction $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {\n  // tracks the active scope, in case restore and contain are both false.\n  // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n  (0, $cgawC$useLayoutEffect)(() => {\n    if (restore || contain) return;\n    let scope = scopeRef.current;\n    const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);\n    let onFocus = e => {\n      let target = e.target;\n      if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;else if (!$9bf71ea28793e738$var$isElementInAnyScope(target)) $9bf71ea28793e738$var$activeScope = null;\n    };\n    ownerDocument.addEventListener(\"focusin\", onFocus, false);\n    scope === null || scope === void 0 ? void 0 : scope.forEach(element => element.addEventListener(\"focusin\", onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n      scope === null || scope === void 0 ? void 0 : scope.forEach(element => element.removeEventListener(\"focusin\", onFocus, false));\n    };\n  }, [scopeRef, restore, contain]);\n}\nfunction $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {\n  let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.nodeToRestore) return false;\n    scope = scope.parent;\n  }\n  return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;\n}\nfunction $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {\n  // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n  // eslint-disable-next-line no-restricted-globals\n  const nodeToRestoreRef = (0, $cgawC$useRef)(typeof document !== \"undefined\" ? (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement : null);\n  // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n  // restoring-non-containing scopes should only care if they become active so they can perform the restore\n  (0, $cgawC$useLayoutEffect)(() => {\n    let scope = scopeRef.current;\n    const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);\n    if (!restoreFocus || contain) return;\n    let onFocus = () => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n    };\n    ownerDocument.addEventListener(\"focusin\", onFocus, false);\n    scope === null || scope === void 0 ? void 0 : scope.forEach(element => element.addEventListener(\"focusin\", onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n      scope === null || scope === void 0 ? void 0 : scope.forEach(element => element.removeEventListener(\"focusin\", onFocus, false));\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [scopeRef, contain]);\n  (0, $cgawC$useLayoutEffect)(() => {\n    const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n    if (!restoreFocus) return;\n    // Handle the Tab key so that tabbing out of the scope goes to the next element\n    // after the node that had focus when the scope mounted. This is important when\n    // using portals for overlays, so that focus goes to the expected element when\n    // tabbing out of the overlay.\n    let onKeyDown = e => {\n      if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef) || e.isComposing) return;\n      let focusedElement = ownerDocument.activeElement;\n      if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current)) return;\n      let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n      if (!treeNode) return;\n      let nodeToRestore = treeNode.nodeToRestore;\n      // Create a DOM tree walker that matches all tabbable elements\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(ownerDocument.body, {\n        tabbable: true\n      });\n      // Find the next tabbable element after the currently focused element\n      walker.currentNode = focusedElement;\n      let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n      if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {\n        nodeToRestore = undefined;\n        treeNode.nodeToRestore = undefined;\n      }\n      // If there is no next element, or it is outside the current scope, move focus to the\n      // next element after the node to restore to instead.\n      if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n        walker.currentNode = nodeToRestore;\n        // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n        do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode(); while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current));\n        e.preventDefault();\n        e.stopPropagation();\n        if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);else\n          // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n          // then move focus to the body.\n          // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n          if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();else $9bf71ea28793e738$var$focusElement(nodeToRestore, true);\n      }\n    };\n    if (!contain) ownerDocument.addEventListener(\"keydown\", onKeyDown, true);\n    return () => {\n      if (!contain) ownerDocument.removeEventListener(\"keydown\", onKeyDown, true);\n    };\n  }, [scopeRef, restoreFocus, contain]);\n  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n  (0, $cgawC$useLayoutEffect)(() => {\n    const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n    if (!restoreFocus) return;\n    let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n    if (!treeNode) return;\n    var _nodeToRestoreRef_current;\n    treeNode.nodeToRestore = (_nodeToRestoreRef_current = nodeToRestoreRef.current) !== null && _nodeToRestoreRef_current !== void 0 ? _nodeToRestoreRef_current : undefined;\n    return () => {\n      let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n      if (!treeNode) return;\n      let nodeToRestore = treeNode.nodeToRestore;\n      // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n      if (restoreFocus && nodeToRestore && (\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      $9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === ownerDocument.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {\n        // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n        let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();\n        requestAnimationFrame(() => {\n          // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n          if (ownerDocument.activeElement === ownerDocument.body) {\n            // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n            let treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                $9bf71ea28793e738$var$focusElement(treeNode.nodeToRestore);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n            // If no nodeToRestore was found, focus the first element in the nearest\n            // ancestor scope that is still in the tree.\n            treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.scopeRef && treeNode.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {\n                $9bf71ea28793e738$var$focusFirstInScope(treeNode.scopeRef.current, true);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n          }\n        });\n      }\n    };\n  }, [scopeRef, restoreFocus]);\n}\nfunction $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {\n  let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;\n  let walker = (0, $cgawC$getOwnerDocument)(root).createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n    acceptNode(node) {\n      var _opts_from;\n      // Skip nodes inside the starting node.\n      if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;\n      if (node.matches(selector) && (0, $645f2e67b85a24c9$export$e989c0fffaa6b27a)(node) && (!scope || $9bf71ea28793e738$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;\n      return NodeFilter.FILTER_SKIP;\n    }\n  });\n  if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;\n  return walker;\n}\nfunction $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {\n  return {\n    focusNext(opts = {}) {\n      let root = ref.current;\n      if (!root) return null;\n      let {\n        from: from,\n        tabbable = defaultOptions.tabbable,\n        wrap = defaultOptions.wrap,\n        accept = defaultOptions.accept\n      } = opts;\n      let node = from || (0, $cgawC$getOwnerDocument)(root).activeElement;\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n        tabbable: tabbable,\n        accept: accept\n      });\n      if (root.contains(node)) walker.currentNode = node;\n      let nextNode = walker.nextNode();\n      if (!nextNode && wrap) {\n        walker.currentNode = root;\n        nextNode = walker.nextNode();\n      }\n      if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n      return nextNode;\n    },\n    focusPrevious(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) return null;\n      let {\n        from: from,\n        tabbable = defaultOptions.tabbable,\n        wrap = defaultOptions.wrap,\n        accept = defaultOptions.accept\n      } = opts;\n      let node = from || (0, $cgawC$getOwnerDocument)(root).activeElement;\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n        tabbable: tabbable,\n        accept: accept\n      });\n      if (root.contains(node)) walker.currentNode = node;else {\n        let next = $9bf71ea28793e738$var$last(walker);\n        if (next) $9bf71ea28793e738$var$focusElement(next, true);\n        return next !== null && next !== void 0 ? next : null;\n      }\n      let previousNode = walker.previousNode();\n      if (!previousNode && wrap) {\n        walker.currentNode = root;\n        let lastNode = $9bf71ea28793e738$var$last(walker);\n        if (!lastNode)\n          // couldn't wrap\n          return null;\n        previousNode = lastNode;\n      }\n      if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n      return previousNode !== null && previousNode !== void 0 ? previousNode : null;\n    },\n    focusFirst(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) return null;\n      let {\n        tabbable = defaultOptions.tabbable,\n        accept = defaultOptions.accept\n      } = opts;\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n        tabbable: tabbable,\n        accept: accept\n      });\n      let nextNode = walker.nextNode();\n      if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n      return nextNode;\n    },\n    focusLast(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) return null;\n      let {\n        tabbable = defaultOptions.tabbable,\n        accept = defaultOptions.accept\n      } = opts;\n      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n        tabbable: tabbable,\n        accept: accept\n      });\n      let next = $9bf71ea28793e738$var$last(walker);\n      if (next) $9bf71ea28793e738$var$focusElement(next, true);\n      return next !== null && next !== void 0 ? next : null;\n    }\n  };\n}\nfunction $9bf71ea28793e738$var$last(walker) {\n  let next = undefined;\n  let last;\n  do {\n    last = walker.lastChild();\n    if (last) next = last;\n  } while (last);\n  return next;\n}\nclass $9bf71ea28793e738$var$Tree {\n  get size() {\n    return this.fastMap.size;\n  }\n  getTreeNode(data) {\n    return this.fastMap.get(data);\n  }\n  addTreeNode(scopeRef, parent, nodeToRestore) {\n    let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);\n    if (!parentNode) return;\n    let node = new $9bf71ea28793e738$var$TreeNode({\n      scopeRef: scopeRef\n    });\n    parentNode.addChild(node);\n    node.parent = parentNode;\n    this.fastMap.set(scopeRef, node);\n    if (nodeToRestore) node.nodeToRestore = nodeToRestore;\n  }\n  addNode(node) {\n    this.fastMap.set(node.scopeRef, node);\n  }\n  removeTreeNode(scopeRef) {\n    // never remove the root\n    if (scopeRef === null) return;\n    let node = this.fastMap.get(scopeRef);\n    if (!node) return;\n    let parentNode = node.parent;\n    // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n    // if we are, then replace the siblings restore with the restore from the scope we're removing\n    for (let current of this.traverse()) if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef && node.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;\n    let children = node.children;\n    if (parentNode) {\n      parentNode.removeChild(node);\n      if (children.size > 0) children.forEach(child => parentNode && parentNode.addChild(child));\n    }\n    this.fastMap.delete(node.scopeRef);\n  }\n  // Pre Order Depth First\n  *traverse(node = this.root) {\n    if (node.scopeRef != null) yield node;\n    if (node.children.size > 0) for (let child of node.children) yield* this.traverse(child);\n  }\n  clone() {\n    var _node_parent;\n    let newTree = new $9bf71ea28793e738$var$Tree();\n    var _node_parent_scopeRef;\n    for (let node of this.traverse()) newTree.addTreeNode(node.scopeRef, (_node_parent_scopeRef = (_node_parent = node.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node.nodeToRestore);\n    return newTree;\n  }\n  constructor() {\n    this.fastMap = new Map();\n    this.root = new $9bf71ea28793e738$var$TreeNode({\n      scopeRef: null\n    });\n    this.fastMap.set(null, this.root);\n  }\n}\nclass $9bf71ea28793e738$var$TreeNode {\n  addChild(node) {\n    this.children.add(node);\n    node.parent = this;\n  }\n  removeChild(node) {\n    this.children.delete(node);\n    node.parent = undefined;\n  }\n  constructor(props) {\n    this.children = new Set();\n    this.contain = false;\n    this.scopeRef = props.scopeRef;\n  }\n}\nlet $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();\nexport { $9bf71ea28793e738$export$20e40289641fbbb6 as FocusScope, $9bf71ea28793e738$export$d06fae2ee68b101e as focusScopeTree, $9bf71ea28793e738$export$10c5169755ce7bd7 as useFocusManager, $9bf71ea28793e738$export$2d6ec8fc375ceafa as getFocusableTreeWalker, $9bf71ea28793e738$export$4c063cf1350e6fed as isFocusable, $9bf71ea28793e738$export$1258395f99bf9cbf as isElementInChildOfActiveScope, $9bf71ea28793e738$export$c5251b9e124bf29 as createFocusManager };","map":{"version":3,"names":["focusSafely","$6a99195332edec8b$export$80f3e147d781571c","isElementVisible","$645f2e67b85a24c9$export$e989c0fffaa6b27a","useLayoutEffect","$cgawC$useLayoutEffect","getOwnerDocument","$cgawC$getOwnerDocument","$cgawC$react","useRef","$cgawC$useRef","useContext","$cgawC$useContext","useMemo","$cgawC$useMemo","useEffect","$cgawC$useEffect","$9bf71ea28793e738$var$FocusContext","createContext","$9bf71ea28793e738$var$activeScope","$9bf71ea28793e738$export$20e40289641fbbb6","props","children","contain","restoreFocus","autoFocus","startRef","endRef","scopeRef","parentNode","node","$9bf71ea28793e738$var$TreeNode","parent","$9bf71ea28793e738$export$d06fae2ee68b101e","root","getTreeNode","$9bf71ea28793e738$var$isAncestorScope","activeNode","addChild","addNode","_startRef_current","current","nextSibling","nodes","push","$9bf71ea28793e738$var$useActiveScopeTracker","$9bf71ea28793e738$var$useFocusContainment","$9bf71ea28793e738$var$useRestoreFocus","$9bf71ea28793e738$var$useAutoFocus","activeElement","undefined","scope","$9bf71ea28793e738$var$isElementInScope","traverse","_focusScopeTree_getTreeNode_parent","_focusScopeTree_getTreeNode","_focusScopeTree_getTreeNode_parent_scopeRef","parentScope","removeTreeNode","focusManager","$9bf71ea28793e738$var$createFocusManagerForScope","value","createElement","Provider","hidden","ref","$9bf71ea28793e738$export$10c5169755ce7bd7","_useContext","focusNext","opts","from","tabbable","wrap","accept","sentinel","previousElementSibling","scopeRoot","$9bf71ea28793e738$var$getScopeRoot","walker","$9bf71ea28793e738$export$2d6ec8fc375ceafa","currentNode","nextNode","$9bf71ea28793e738$var$focusElement","focusPrevious","length","nextElementSibling","previousNode","focusFirst","focusLast","$9bf71ea28793e738$var$focusableElements","$9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR","join","$9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR","$9bf71ea28793e738$export$4c063cf1350e6fed","element","matches","parentElement","$9bf71ea28793e738$var$shouldContainFocus","focusedNode","raf","cancelAnimationFrame","ownerDocument","onKeyDown","e","key","altKey","ctrlKey","metaKey","isComposing","focusedElement","nextElement","shiftKey","preventDefault","onFocus","target","$9bf71ea28793e738$var$isElementInChildScope","focus","$9bf71ea28793e738$var$focusFirstInScope","onBlur","requestAnimationFrame","body","contains","_focusedNode_current","addEventListener","forEach","removeEventListener","$9bf71ea28793e738$var$isElementInAnyScope","some","Element","closest","s","$9bf71ea28793e738$export$1258395f99bf9cbf","ancestor","scroll","err","autoFocusRef","restore","$9bf71ea28793e738$var$shouldRestoreFocus","nodeToRestore","nodeToRestoreRef","document","treeNode","stopPropagation","blur","_nodeToRestoreRef_current","clonedTree","clone","isConnected","selector","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","_opts_from","FILTER_REJECT","FILTER_ACCEPT","FILTER_SKIP","$9bf71ea28793e738$export$c5251b9e124bf29","defaultOptions","next","$9bf71ea28793e738$var$last","lastNode","last","lastChild","$9bf71ea28793e738$var$Tree","size","fastMap","data","get","addTreeNode","set","removeChild","child","delete","_node_parent","newTree","_node_parent_scopeRef","constructor","Map","add","Set","FocusScope","focusScopeTree","useFocusManager","getFocusableTreeWalker","isFocusable","isElementInChildOfActiveScope","createFocusManager"],"sources":["/Users/development/Downloads/wastewise-master/node_modules/@react-aria/focus/dist/FocusScope.mjs"],"sourcesContent":["import {focusSafely as $6a99195332edec8b$export$80f3e147d781571c} from \"./focusSafely.mjs\";\nimport {isElementVisible as $645f2e67b85a24c9$export$e989c0fffaa6b27a} from \"./isElementVisible.mjs\";\nimport {useLayoutEffect as $cgawC$useLayoutEffect, getOwnerDocument as $cgawC$getOwnerDocument} from \"@react-aria/utils\";\nimport $cgawC$react, {useRef as $cgawC$useRef, useContext as $cgawC$useContext, useMemo as $cgawC$useMemo, useEffect as $cgawC$useEffect} from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\nconst $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/ (0, $cgawC$react).createContext(null);\nlet $9bf71ea28793e738$var$activeScope = null;\nfunction $9bf71ea28793e738$export$20e40289641fbbb6(props) {\n    let { children: children, contain: contain, restoreFocus: restoreFocus, autoFocus: autoFocus } = props;\n    let startRef = (0, $cgawC$useRef)(null);\n    let endRef = (0, $cgawC$useRef)(null);\n    let scopeRef = (0, $cgawC$useRef)([]);\n    let { parentNode: parentNode } = (0, $cgawC$useContext)($9bf71ea28793e738$var$FocusContext) || {};\n    // Create a tree node here so we can add children to it even before it is added to the tree.\n    let node = (0, $cgawC$useMemo)(()=>new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        }), [\n        scopeRef\n    ]);\n    (0, $cgawC$useLayoutEffect)(()=>{\n        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n        // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n        // that is being added should get the activeScope as its parent.\n        let parent = parentNode || $9bf71ea28793e738$export$d06fae2ee68b101e.root;\n        if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, parent.scopeRef)) {\n            let activeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n            if (activeNode) parent = activeNode;\n        }\n        // Add the node to the parent, and to the tree.\n        parent.addChild(node);\n        $9bf71ea28793e738$export$d06fae2ee68b101e.addNode(node);\n    }, [\n        node,\n        parentNode\n    ]);\n    (0, $cgawC$useLayoutEffect)(()=>{\n        let node = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n        if (node) node.contain = !!contain;\n    }, [\n        contain\n    ]);\n    (0, $cgawC$useLayoutEffect)(()=>{\n        var _startRef_current;\n        // Find all rendered nodes between the sentinels and add them to the scope.\n        let node = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;\n        let nodes = [];\n        while(node && node !== endRef.current){\n            nodes.push(node);\n            node = node.nextSibling;\n        }\n        scopeRef.current = nodes;\n    }, [\n        children\n    ]);\n    $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);\n    $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);\n    // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n    // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n    (0, $cgawC$useEffect)(()=>{\n        const activeElement = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;\n        let scope = null;\n        if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {\n            // We need to traverse the focusScope tree and find the bottom most scope that\n            // contains the active element and set that as the activeScope.\n            for (let node of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse())if (node.scopeRef && $9bf71ea28793e738$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;\n            if (scope === $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $9bf71ea28793e738$var$activeScope = scope.scopeRef;\n        }\n    }, [\n        scopeRef\n    ]);\n    // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n    // in useRestoreFocus cleanup runs.\n    (0, $cgawC$useLayoutEffect)(()=>{\n        return ()=>{\n            var _focusScopeTree_getTreeNode_parent, _focusScopeTree_getTreeNode;\n            var _focusScopeTree_getTreeNode_parent_scopeRef;\n            // Scope may have been re-parented.\n            let parentScope = (_focusScopeTree_getTreeNode_parent_scopeRef = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : (_focusScopeTree_getTreeNode_parent = _focusScopeTree_getTreeNode.parent) === null || _focusScopeTree_getTreeNode_parent === void 0 ? void 0 : _focusScopeTree_getTreeNode_parent.scopeRef) !== null && _focusScopeTree_getTreeNode_parent_scopeRef !== void 0 ? _focusScopeTree_getTreeNode_parent_scopeRef : null;\n            if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope))) $9bf71ea28793e738$var$activeScope = parentScope;\n            $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);\n        };\n    }, [\n        scopeRef\n    ]);\n    let focusManager = (0, $cgawC$useMemo)(()=>$9bf71ea28793e738$var$createFocusManagerForScope(scopeRef), []);\n    let value = (0, $cgawC$useMemo)(()=>({\n            focusManager: focusManager,\n            parentNode: node\n        }), [\n        node,\n        focusManager\n    ]);\n    return /*#__PURE__*/ (0, $cgawC$react).createElement($9bf71ea28793e738$var$FocusContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, $cgawC$react).createElement(\"span\", {\n        \"data-focus-scope-start\": true,\n        hidden: true,\n        ref: startRef\n    }), children, /*#__PURE__*/ (0, $cgawC$react).createElement(\"span\", {\n        \"data-focus-scope-end\": true,\n        hidden: true,\n        ref: endRef\n    }));\n}\nfunction $9bf71ea28793e738$export$10c5169755ce7bd7() {\n    var _useContext;\n    return (_useContext = (0, $cgawC$useContext)($9bf71ea28793e738$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;\n}\nfunction $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {\n    return {\n        focusNext (opts = {}) {\n            let scope = scopeRef.current;\n            let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;\n            let node = from || (0, $cgawC$getOwnerDocument)(scope[0]).activeElement;\n            let sentinel = scope[0].previousElementSibling;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = sentinel;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = {}) {\n            let scope = scopeRef.current;\n            let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;\n            let node = from || (0, $cgawC$getOwnerDocument)(scope[0]).activeElement;\n            let sentinel = scope[scope.length - 1].nextElementSibling;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = sentinel;\n                previousNode = walker.previousNode();\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        },\n        focusFirst (opts = {}) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable, accept: accept } = opts;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[0].previousElementSibling;\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = {}) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable, accept: accept } = opts;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[scope.length - 1].nextElementSibling;\n            let previousNode = walker.previousNode();\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        }\n    };\n}\nconst $9bf71ea28793e738$var$focusableElements = [\n    \"input:not([disabled]):not([type=hidden])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"button:not([disabled])\",\n    \"a[href]\",\n    \"area[href]\",\n    \"summary\",\n    \"iframe\",\n    \"object\",\n    \"embed\",\n    \"audio[controls]\",\n    \"video[controls]\",\n    \"[contenteditable]\"\n];\nconst $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(\":not([hidden]),\") + \",[tabindex]:not([disabled]):not([hidden])\";\n$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\nfunction $9bf71ea28793e738$export$4c063cf1350e6fed(element) {\n    return element.matches($9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR);\n}\nfunction $9bf71ea28793e738$var$getScopeRoot(scope) {\n    return scope[0].parentElement;\n}\nfunction $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.contain) return false;\n        scope = scope.parent;\n    }\n    return true;\n}\nfunction $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {\n    let focusedNode = (0, $cgawC$useRef)();\n    let raf = (0, $cgawC$useRef)();\n    (0, $cgawC$useLayoutEffect)(()=>{\n        let scope = scopeRef.current;\n        if (!contain) {\n            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n            if (raf.current) {\n                cancelAnimationFrame(raf.current);\n                raf.current = undefined;\n            }\n            return;\n        }\n        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);\n        // Handle the Tab key to contain focus within the scope\n        let onKeyDown = (e)=>{\n            if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef) || e.isComposing) return;\n            let focusedElement = ownerDocument.activeElement;\n            let scope = scopeRef.current;\n            if (!scope || !$9bf71ea28793e738$var$isElementInScope(focusedElement, scope)) return;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: true\n            }, scope);\n            if (!focusedElement) return;\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nextElement) {\n                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;\n                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            }\n            e.preventDefault();\n            if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n        };\n        let onFocus = (e)=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e.target, scopeRef.current)) {\n                $9bf71ea28793e738$var$activeScope = scopeRef;\n                focusedNode.current = e.target;\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e.target, scopeRef)) {\n                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n                // restore focus to the previously focused node or the first tabbable element in the active scope.\n                if (focusedNode.current) focusedNode.current.focus();\n                else if ($9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;\n        };\n        let onBlur = (e)=>{\n            // Firefox doesn't shift focus back to the Dialog properly without this\n            if (raf.current) cancelAnimationFrame(raf.current);\n            raf.current = requestAnimationFrame(()=>{\n                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n                if (ownerDocument.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n                    $9bf71ea28793e738$var$activeScope = scopeRef;\n                    if (ownerDocument.body.contains(e.target)) {\n                        var _focusedNode_current;\n                        focusedNode.current = e.target;\n                        (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();\n                    } else if ($9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n                }\n            });\n        };\n        ownerDocument.addEventListener(\"keydown\", onKeyDown, false);\n        ownerDocument.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusout\", onBlur, false));\n        return ()=>{\n            ownerDocument.removeEventListener(\"keydown\", onKeyDown, false);\n            ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusout\", onBlur, false));\n        };\n    }, [\n        scopeRef,\n        contain\n    ]);\n    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n    // eslint-disable-next-line arrow-body-style\n    (0, $cgawC$useLayoutEffect)(()=>{\n        return ()=>{\n            if (raf.current) cancelAnimationFrame(raf.current);\n        };\n    }, [\n        raf\n    ]);\n}\nfunction $9bf71ea28793e738$var$isElementInAnyScope(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element);\n}\nfunction $9bf71ea28793e738$var$isElementInScope(element, scope) {\n    if (!element) return false;\n    if (!scope) return false;\n    return scope.some((node)=>node.contains(element));\n}\nfunction $9bf71ea28793e738$var$isElementInChildScope(element, scope = null) {\n    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n    if (element instanceof Element && element.closest(\"[data-react-aria-top-layer]\")) return true;\n    // node.contains in isElementInScope covers child scopes that are also DOM children,\n    // but does not cover child scopes in portals.\n    for (let { scopeRef: s } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))){\n        if (s && $9bf71ea28793e738$var$isElementInScope(element, s.current)) return true;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$export$1258395f99bf9cbf(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element, $9bf71ea28793e738$var$activeScope);\n}\nfunction $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {\n    var _focusScopeTree_getTreeNode;\n    let parent = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;\n    while(parent){\n        if (parent.scopeRef === ancestor) return true;\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$var$focusElement(element, scroll = false) {\n    if (element != null && !scroll) try {\n        (0, $6a99195332edec8b$export$80f3e147d781571c)(element);\n    } catch (err) {\n    // ignore\n    }\n    else if (element != null) try {\n        element.focus();\n    } catch (err) {\n    // ignore\n    }\n}\nfunction $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {\n    let sentinel = scope[0].previousElementSibling;\n    let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n    let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: tabbable\n    }, scope);\n    walker.currentNode = sentinel;\n    let nextNode = walker.nextNode();\n    // If the scope does not contain a tabbable element, use the first focusable element.\n    if (tabbable && !nextNode) {\n        scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n        walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n            tabbable: false\n        }, scope);\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode();\n    }\n    $9bf71ea28793e738$var$focusElement(nextNode);\n}\nfunction $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {\n    const autoFocusRef = (0, $cgawC$react).useRef(autoFocus);\n    (0, $cgawC$useEffect)(()=>{\n        if (autoFocusRef.current) {\n            $9bf71ea28793e738$var$activeScope = scopeRef;\n            const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n            if (!$9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, $9bf71ea28793e738$var$activeScope.current) && scopeRef.current) $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);\n        }\n        autoFocusRef.current = false;\n    }, [\n        scopeRef\n    ]);\n}\nfunction $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {\n    // tracks the active scope, in case restore and contain are both false.\n    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n    (0, $cgawC$useLayoutEffect)(()=>{\n        if (restore || contain) return;\n        let scope = scopeRef.current;\n        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);\n        let onFocus = (e)=>{\n            let target = e.target;\n            if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n            else if (!$9bf71ea28793e738$var$isElementInAnyScope(target)) $9bf71ea28793e738$var$activeScope = null;\n        };\n        ownerDocument.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        return ()=>{\n            ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n        };\n    }, [\n        scopeRef,\n        restore,\n        contain\n    ]);\n}\nfunction $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.nodeToRestore) return false;\n        scope = scope.parent;\n    }\n    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;\n}\nfunction $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {\n    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n    // eslint-disable-next-line no-restricted-globals\n    const nodeToRestoreRef = (0, $cgawC$useRef)(typeof document !== \"undefined\" ? (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement : null);\n    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n    // restoring-non-containing scopes should only care if they become active so they can perform the restore\n    (0, $cgawC$useLayoutEffect)(()=>{\n        let scope = scopeRef.current;\n        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);\n        if (!restoreFocus || contain) return;\n        let onFocus = ()=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n        };\n        ownerDocument.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        return ()=>{\n            ownerDocument.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        scopeRef,\n        contain\n    ]);\n    (0, $cgawC$useLayoutEffect)(()=>{\n        const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n        if (!restoreFocus) return;\n        // Handle the Tab key so that tabbing out of the scope goes to the next element\n        // after the node that had focus when the scope mounted. This is important when\n        // using portals for overlays, so that focus goes to the expected element when\n        // tabbing out of the overlay.\n        let onKeyDown = (e)=>{\n            if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef) || e.isComposing) return;\n            let focusedElement = ownerDocument.activeElement;\n            if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current)) return;\n            let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n            if (!treeNode) return;\n            let nodeToRestore = treeNode.nodeToRestore;\n            // Create a DOM tree walker that matches all tabbable elements\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(ownerDocument.body, {\n                tabbable: true\n            });\n            // Find the next tabbable element after the currently focused element\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {\n                nodeToRestore = undefined;\n                treeNode.nodeToRestore = undefined;\n            }\n            // If there is no next element, or it is outside the current scope, move focus to the\n            // next element after the node to restore to instead.\n            if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n                walker.currentNode = nodeToRestore;\n                // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n                while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current));\n                e.preventDefault();\n                e.stopPropagation();\n                if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n                // then move focus to the body.\n                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n                if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();\n                else $9bf71ea28793e738$var$focusElement(nodeToRestore, true);\n            }\n        };\n        if (!contain) ownerDocument.addEventListener(\"keydown\", onKeyDown, true);\n        return ()=>{\n            if (!contain) ownerDocument.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n    }, [\n        scopeRef,\n        restoreFocus,\n        contain\n    ]);\n    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n    (0, $cgawC$useLayoutEffect)(()=>{\n        const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);\n        if (!restoreFocus) return;\n        let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n        if (!treeNode) return;\n        var _nodeToRestoreRef_current;\n        treeNode.nodeToRestore = (_nodeToRestoreRef_current = nodeToRestoreRef.current) !== null && _nodeToRestoreRef_current !== void 0 ? _nodeToRestoreRef_current : undefined;\n        return ()=>{\n            let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n            if (!treeNode) return;\n            let nodeToRestore = treeNode.nodeToRestore;\n            // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps\n            ($9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === ownerDocument.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {\n                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n                let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();\n                requestAnimationFrame(()=>{\n                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n                    if (ownerDocument.activeElement === ownerDocument.body) {\n                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n                        let treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                                $9bf71ea28793e738$var$focusElement(treeNode.nodeToRestore);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                        // If no nodeToRestore was found, focus the first element in the nearest\n                        // ancestor scope that is still in the tree.\n                        treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.scopeRef && treeNode.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {\n                                $9bf71ea28793e738$var$focusFirstInScope(treeNode.scopeRef.current, true);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                    }\n                });\n            }\n        };\n    }, [\n        scopeRef,\n        restoreFocus\n    ]);\n}\nfunction $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {\n    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;\n    let walker = (0, $cgawC$getOwnerDocument)(root).createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n        acceptNode (node) {\n            var _opts_from;\n            // Skip nodes inside the starting node.\n            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;\n            if (node.matches(selector) && (0, $645f2e67b85a24c9$export$e989c0fffaa6b27a)(node) && (!scope || $9bf71ea28793e738$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;\n            return NodeFilter.FILTER_SKIP;\n        }\n    });\n    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;\n    return walker;\n}\nfunction $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {\n    return {\n        focusNext (opts = {}) {\n            let root = ref.current;\n            if (!root) return null;\n            let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;\n            let node = from || (0, $cgawC$getOwnerDocument)(root).activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = root;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;\n            let node = from || (0, $cgawC$getOwnerDocument)(root).activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            else {\n                let next = $9bf71ea28793e738$var$last(walker);\n                if (next) $9bf71ea28793e738$var$focusElement(next, true);\n                return next !== null && next !== void 0 ? next : null;\n            }\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = root;\n                let lastNode = $9bf71ea28793e738$var$last(walker);\n                if (!lastNode) // couldn't wrap\n                return null;\n                previousNode = lastNode;\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode !== null && previousNode !== void 0 ? previousNode : null;\n        },\n        focusFirst (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { tabbable: tabbable = defaultOptions.tabbable, accept: accept = defaultOptions.accept } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { tabbable: tabbable = defaultOptions.tabbable, accept: accept = defaultOptions.accept } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let next = $9bf71ea28793e738$var$last(walker);\n            if (next) $9bf71ea28793e738$var$focusElement(next, true);\n            return next !== null && next !== void 0 ? next : null;\n        }\n    };\n}\nfunction $9bf71ea28793e738$var$last(walker) {\n    let next = undefined;\n    let last;\n    do {\n        last = walker.lastChild();\n        if (last) next = last;\n    }while (last);\n    return next;\n}\nclass $9bf71ea28793e738$var$Tree {\n    get size() {\n        return this.fastMap.size;\n    }\n    getTreeNode(data) {\n        return this.fastMap.get(data);\n    }\n    addTreeNode(scopeRef, parent, nodeToRestore) {\n        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);\n        if (!parentNode) return;\n        let node = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        });\n        parentNode.addChild(node);\n        node.parent = parentNode;\n        this.fastMap.set(scopeRef, node);\n        if (nodeToRestore) node.nodeToRestore = nodeToRestore;\n    }\n    addNode(node) {\n        this.fastMap.set(node.scopeRef, node);\n    }\n    removeTreeNode(scopeRef) {\n        // never remove the root\n        if (scopeRef === null) return;\n        let node = this.fastMap.get(scopeRef);\n        if (!node) return;\n        let parentNode = node.parent;\n        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n        // if we are, then replace the siblings restore with the restore from the scope we're removing\n        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef && node.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;\n        let children = node.children;\n        if (parentNode) {\n            parentNode.removeChild(node);\n            if (children.size > 0) children.forEach((child)=>parentNode && parentNode.addChild(child));\n        }\n        this.fastMap.delete(node.scopeRef);\n    }\n    // Pre Order Depth First\n    *traverse(node = this.root) {\n        if (node.scopeRef != null) yield node;\n        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);\n    }\n    clone() {\n        var _node_parent;\n        let newTree = new $9bf71ea28793e738$var$Tree();\n        var _node_parent_scopeRef;\n        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, (_node_parent_scopeRef = (_node_parent = node.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node.nodeToRestore);\n        return newTree;\n    }\n    constructor(){\n        this.fastMap = new Map();\n        this.root = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: null\n        });\n        this.fastMap.set(null, this.root);\n    }\n}\nclass $9bf71ea28793e738$var$TreeNode {\n    addChild(node) {\n        this.children.add(node);\n        node.parent = this;\n    }\n    removeChild(node) {\n        this.children.delete(node);\n        node.parent = undefined;\n    }\n    constructor(props){\n        this.children = new Set();\n        this.contain = false;\n        this.scopeRef = props.scopeRef;\n    }\n}\nlet $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();\n\n\nexport {$9bf71ea28793e738$export$20e40289641fbbb6 as FocusScope, $9bf71ea28793e738$export$d06fae2ee68b101e as focusScopeTree, $9bf71ea28793e738$export$10c5169755ce7bd7 as useFocusManager, $9bf71ea28793e738$export$2d6ec8fc375ceafa as getFocusableTreeWalker, $9bf71ea28793e738$export$4c063cf1350e6fed as isFocusable, $9bf71ea28793e738$export$1258395f99bf9cbf as isElementInChildOfActiveScope, $9bf71ea28793e738$export$c5251b9e124bf29 as createFocusManager};\n//# sourceMappingURL=FocusScope.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}