{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n  if (typeof window === \"undefined\") return;\n  function isTransitionEvent(event) {\n    return \"propertyName\" in event;\n  }\n  let onTransitionStart = e => {\n    if (!isTransitionEvent(e) || !e.target) return;\n    // Add the transitioning property to the list for this element.\n    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n    if (!transitions) {\n      transitions = new Set();\n      $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n      // The transitioncancel event must be registered on the element itself, rather than as a global\n      // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n      // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n      e.target.addEventListener(\"transitioncancel\", onTransitionEnd, {\n        once: true\n      });\n    }\n    transitions.add(e.propertyName);\n  };\n  let onTransitionEnd = e => {\n    if (!isTransitionEvent(e) || !e.target) return;\n    // Remove property from list of transitioning properties.\n    let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n    if (!properties) return;\n    properties.delete(e.propertyName);\n    // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n    if (properties.size === 0) {\n      e.target.removeEventListener(\"transitioncancel\", onTransitionEnd);\n      $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n    }\n    // If no transitioning elements, call all of the queued callbacks.\n    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks) cb();\n      $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n    }\n  };\n  document.body.addEventListener(\"transitionrun\", onTransitionStart);\n  document.body.addEventListener(\"transitionend\", onTransitionEnd);\n}\nif (typeof document !== \"undefined\") {\n  if (document.readyState !== \"loading\") $bbed8b41f857bcc0$var$setupGlobalEvents();else document.addEventListener(\"DOMContentLoaded\", $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n  // Wait one frame to see if an animation starts, e.g. a transition on mount.\n  requestAnimationFrame(() => {\n    // If no transitions are running, call the function immediately.\n    // Otherwise, add it to a list of callbacks to run at the end of the animation.\n    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n  });\n}\nexport { $bbed8b41f857bcc0$export$24490316f764c430 as runAfterTransition };","map":{"version":3,"names":["$bbed8b41f857bcc0$var$transitionsByElement","Map","$bbed8b41f857bcc0$var$transitionCallbacks","Set","$bbed8b41f857bcc0$var$setupGlobalEvents","window","isTransitionEvent","event","onTransitionStart","e","target","transitions","get","set","addEventListener","onTransitionEnd","once","add","propertyName","properties","delete","size","removeEventListener","cb","clear","document","body","readyState","$bbed8b41f857bcc0$export$24490316f764c430","fn","requestAnimationFrame","runAfterTransition"],"sources":["/Users/development/Downloads/wastewise-master/node_modules/@react-aria/utils/dist/runAfterTransition.mjs"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n    if (typeof window === \"undefined\") return;\n    function isTransitionEvent(event) {\n        return \"propertyName\" in event;\n    }\n    let onTransitionStart = (e)=>{\n        if (!isTransitionEvent(e) || !e.target) return;\n        // Add the transitioning property to the list for this element.\n        let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!transitions) {\n            transitions = new Set();\n            $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n            // The transitioncancel event must be registered on the element itself, rather than as a global\n            // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n            e.target.addEventListener(\"transitioncancel\", onTransitionEnd, {\n                once: true\n            });\n        }\n        transitions.add(e.propertyName);\n    };\n    let onTransitionEnd = (e)=>{\n        if (!isTransitionEvent(e) || !e.target) return;\n        // Remove property from list of transitioning properties.\n        let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!properties) return;\n        properties.delete(e.propertyName);\n        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n        if (properties.size === 0) {\n            e.target.removeEventListener(\"transitioncancel\", onTransitionEnd);\n            $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n        }\n        // If no transitioning elements, call all of the queued callbacks.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n            for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)cb();\n            $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n        }\n    };\n    document.body.addEventListener(\"transitionrun\", onTransitionStart);\n    document.body.addEventListener(\"transitionend\", onTransitionEnd);\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $bbed8b41f857bcc0$var$setupGlobalEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n    // Wait one frame to see if an animation starts, e.g. a transition on mount.\n    requestAnimationFrame(()=>{\n        // If no transitions are running, call the function immediately.\n        // Otherwise, add it to a list of callbacks to run at the end of the animation.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();\n        else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n    });\n}\n\n\nexport {$bbed8b41f857bcc0$export$24490316f764c430 as runAfterTransition};\n//# sourceMappingURL=runAfterTransition.mjs.map\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAVA,CAUI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAIA,0CAA0C,GAAG,IAAIC,GAAG,CAAC,CAAC;AAC1D;AACA,IAAIC,yCAAyC,GAAG,IAAIC,GAAG,CAAC,CAAC;AACzD,SAASC,uCAAuCA,CAAA,EAAG;EAC/C,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;EACnC,SAASC,iBAAiBA,CAACC,KAAK,EAAE;IAC9B,OAAO,cAAc,IAAIA,KAAK;EAClC;EACA,IAAIC,iBAAiB,GAAIC,CAAC,IAAG;IACzB,IAAI,CAACH,iBAAiB,CAACG,CAAC,CAAC,IAAI,CAACA,CAAC,CAACC,MAAM,EAAE;IACxC;IACA,IAAIC,WAAW,GAAGX,0CAA0C,CAACY,GAAG,CAACH,CAAC,CAACC,MAAM,CAAC;IAC1E,IAAI,CAACC,WAAW,EAAE;MACdA,WAAW,GAAG,IAAIR,GAAG,CAAC,CAAC;MACvBH,0CAA0C,CAACa,GAAG,CAACJ,CAAC,CAACC,MAAM,EAAEC,WAAW,CAAC;MACrE;MACA;MACA;MACAF,CAAC,CAACC,MAAM,CAACI,gBAAgB,CAAC,kBAAkB,EAAEC,eAAe,EAAE;QAC3DC,IAAI,EAAE;MACV,CAAC,CAAC;IACN;IACAL,WAAW,CAACM,GAAG,CAACR,CAAC,CAACS,YAAY,CAAC;EACnC,CAAC;EACD,IAAIH,eAAe,GAAIN,CAAC,IAAG;IACvB,IAAI,CAACH,iBAAiB,CAACG,CAAC,CAAC,IAAI,CAACA,CAAC,CAACC,MAAM,EAAE;IACxC;IACA,IAAIS,UAAU,GAAGnB,0CAA0C,CAACY,GAAG,CAACH,CAAC,CAACC,MAAM,CAAC;IACzE,IAAI,CAACS,UAAU,EAAE;IACjBA,UAAU,CAACC,MAAM,CAACX,CAAC,CAACS,YAAY,CAAC;IACjC;IACA,IAAIC,UAAU,CAACE,IAAI,KAAK,CAAC,EAAE;MACvBZ,CAAC,CAACC,MAAM,CAACY,mBAAmB,CAAC,kBAAkB,EAAEP,eAAe,CAAC;MACjEf,0CAA0C,CAACoB,MAAM,CAACX,CAAC,CAACC,MAAM,CAAC;IAC/D;IACA;IACA,IAAIV,0CAA0C,CAACqB,IAAI,KAAK,CAAC,EAAE;MACvD,KAAK,IAAIE,EAAE,IAAIrB,yCAAyC,EAACqB,EAAE,CAAC,CAAC;MAC7DrB,yCAAyC,CAACsB,KAAK,CAAC,CAAC;IACrD;EACJ,CAAC;EACDC,QAAQ,CAACC,IAAI,CAACZ,gBAAgB,CAAC,eAAe,EAAEN,iBAAiB,CAAC;EAClEiB,QAAQ,CAACC,IAAI,CAACZ,gBAAgB,CAAC,eAAe,EAAEC,eAAe,CAAC;AACpE;AACA,IAAI,OAAOU,QAAQ,KAAK,WAAW,EAAE;EACjC,IAAIA,QAAQ,CAACE,UAAU,KAAK,SAAS,EAAEvB,uCAAuC,CAAC,CAAC,CAAC,KAC5EqB,QAAQ,CAACX,gBAAgB,CAAC,kBAAkB,EAAEV,uCAAuC,CAAC;AAC/F;AACA,SAASwB,yCAAyCA,CAACC,EAAE,EAAE;EACnD;EACAC,qBAAqB,CAAC,MAAI;IACtB;IACA;IACA,IAAI9B,0CAA0C,CAACqB,IAAI,KAAK,CAAC,EAAEQ,EAAE,CAAC,CAAC,CAAC,KAC3D3B,yCAAyC,CAACe,GAAG,CAACY,EAAE,CAAC;EAC1D,CAAC,CAAC;AACN;AAGA,SAAQD,yCAAyC,IAAIG,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}